import importlib
import sys
import os
import re
import ast # <-- 确保这一行在文件顶部！
from typing import List, Dict
import collections

# 定义需要重新加载的依赖模块
# 这些模块通常包含配置、凭据或不经常变动但可能在开发时需要更新的辅助函数
DEPENDENT_MODULE_NAMES = [
    "sg_register",  # 假设 sg_register.py 模块名为 sg_register
    "env",          # 假设 env.py 模块名为 env
]

# 全局管理器实例，用于存储 ShotgunDataManager 对象
_manager_instance = None

def get_command():
    """
    提供一个工厂函数，用于在外部获取 ShotgunDataManager 实例。
    这个函数本身不直接创建实例，而是调用 execute()。
    """
    def _command():
        try:
            # 调用 execute() 来获取或刷新管理器实例
            manager = execute()
            return manager
        except Exception as e:
            print(f"Failed to get command: {str(e)}")
            import traceback
            traceback.print_exc()
            return None # 返回None表示失败
    return _command

def execute():
    """
    执行模块的主要功能：初始化或重新初始化 ShotgunDataManager。
    此函数会尝试重新加载依赖模块和当前模块，以实现热更新。
    """
    global _manager_instance
    
    # --- 1. 重新加载依赖模块 ---
    # 遍历并重新加载所有在DEPENDENT_MODULE_NAMES中列出的模块
    for module_name in DEPENDENT_MODULE_NAMES:
        # 只有当模块已经被导入到sys.modules中时才尝试重新加载
        if module_name in sys.modules:
            try:
                importlib.reload(sys.modules[module_name])
                print(f"Successfully reloaded dependent module: {module_name}")
            except Exception as e:
                # 重新加载失败通常意味着模块有语法错误或运行时错误
                print(f"Failed to reload dependent module '{module_name}': {e}")
                import traceback
                traceback.print_exc()
                raise # 如果依赖模块无法重新加载，通常意味着更严重的问题，直接抛出

    # --- 2. 重新加载当前模块 ---
    # 重新加载当前模块，确保ShotgunDataManager类定义是最新的
    try:
        importlib.reload(sys.modules[__name__])
        print(f"Successfully reloaded current module: {__name__}")
    except Exception as e:
        print(f"Failed to reload current module '{__name__}': {e}")
        import traceback
        traceback.print_exc()
        raise # 当前模块无法重新加载，必须抛出错误

    # --- 3. 清空旧的管理器实例 ---
    # 如果存在旧的实例，将其引用清空，并尝试删除它
    # 这确保了新的 ShotgunDataManager 实例将基于重新加载后的类定义创建
    if _manager_instance:
        try:
            # 显式删除引用，有助于Python的垃圾回收机制回收旧对象
            # 但请注意，如果外部仍有对旧实例的引用，它不会被立即回收
            del _manager_instance
            _manager_instance = None
            print("Cleared old _manager_instance.")
        except Exception as e:
            # 捕获清空旧实例时可能发生的任何错误（虽然不常见）
            print(f"Error during clearing old _manager_instance: {e}")
            pass # 忽略此错误，继续尝试创建新实例
    
    # --- 4. 创建新的管理器实例 ---
    try:
        print("Attempting to create ShotgunDataManager...")
        # 这里的 ShotgunDataManager() 应该引用的是重新加载后的类定义
        # 通过 sys.modules[__name__].ShotgunDataManager() 明确指定从当前模块获取
        _manager_instance = sys.modules[__name__].ShotgunDataManager()
        print("Successfully created ShotgunDataManager")
        print(f"Connected to Shotgun server: {_manager_instance.sg.server_info()}")
        print(f"Project: {_manager_instance.HAL_PROJECT}")
        print(f"User: {_manager_instance.HAL_USER_LOGIN}")
        return _manager_instance
    except Exception as e:
        print(f"Failed to create manager: {str(e)}")
        print("Please check your Shotgun credentials in sg_register.py")
        print("And verify environment variables in env.py")
        import traceback
        traceback.print_exc()
        raise # 抛出异常，因为管理器未能成功创建

# ==============================================================================
# ShotgunDataManager 类定义
# ==============================================================================

class ShotgunDataManager:
    def __init__(self):
        # 导入 Shotgun 凭据，确保每次都从最新的 sg_register 模块获取
        from sg_register import login_to_shotgun
        self.sg = login_to_shotgun()
        
        # 导入和使用环境配置，确保每次都从最新的 env 模块获取
        from env import env_config
        self.env = env_config
        
        # 加载环境变量
        self._load_env_vars()
        self.data_store = {}
    
    def _load_env_vars(self):
        """Load environment variables from env config"""
        self.HAL_PROJECT_SGID = int(self.env.HAL_PROJECT_SGID or 0)
        self.HAL_PROJECT = self.env.HAL_PROJECT
        self.HAL_USER_LOGIN = self.env.HAL_USER_LOGIN
        self.HAL_TREE = self.env.HAL_TREE
        
        # Entity-specific variables
        if self.HAL_TREE == "assets":
            self.HAL_ASSET_SGID = int(self.env.HAL_ASSET_SGID or 0)
        elif self.HAL_TREE == "shots":
            self.HAL_SHOT_SGID = int(self.env.HAL_SHOT_SGID or 0)

    def extract_filename_from_url(self, url: str) -> str:
        """Extract base filename without extension from URL"""
        if not url:
            return "No Image"
        match = re.search(r'filename%3D%22([^%]+?)%22', url)
        if match:
            filename = match.group(1).split('.')[0]
            return re.sub(r'[^a-zA-Z0-9_-]', '_', filename)  # Sanitize
        return "Unparsable URL"

    def _categorize_version(self, version_data: Dict):
        """
        Categorize version by entity type using regex patterns from the 'code' field.
        This populates the 'category' key in the version_data dictionary for client-side use.
        """
        entity_type = version_data.get("entity", {}).get("type", "")
        code = version_data.get("code", "").lower()
        
        if entity_type == "Asset":
            pattern = r'(mdl|shd|rig|txt|cgfx-setup|cncpt)'
            match = re.search(pattern, code)
            version_data["category"] = match.group(1) if match else "asset_unknown"
        
        elif entity_type == "Shot":
            pattern = r'(anim|cgfx|comp|layout|lgt|mm|matp|paint|roto)'
            match = re.search(pattern, code)
            version_data["category"] = match.group(1) if match else "shot_unknown"

    def _get_version_number(self, version_code: str) -> int:
        """Extracts the numerical version from a version code (e.g., 'v009' -> 9)"""
        match = re.search(r'_v(\d+)', version_code)
        if match:
            return int(match.group(1))
        return 0
    
    # Helper to get abbreviation for filtering 'code' field
    def _get_category_abbreviation(self, category_name: str) -> str:
        """Map full category names to their code abbreviations."""
        CATEGORY_ABBREVIATIONS = {
            'characters': 'chr',
            'environments': 'env', 
            'props': 'prp',
            'vehicles': 'veh',
            'cgfx': 'cgfx',
            # Add more as needed
        }
        return CATEGORY_ABBREVIATIONS.get(category_name.lower(), '')

    def find_files(self, tab_context: str = "") -> List[Dict]:
        """
        Retrieve and categorize Version entities from Shotgun,
        with specific filtering based on tab_context, without relying on custom Version fields.
        
        Args:
            tab_context: Context string in format "type_part/category_part" (e.g., "mdl/props", "anim/0010").
                         For shots, category_part should be the Sequence code (e.g., "0010").
        """
        # Validate user exists
        current_user = self.sg.find_one('HumanUser', [['login', 'is', self.HAL_USER_LOGIN]], ['id'])
        if not current_user:
            print("Error: Current user not found in Shotgun")
            return []

        # Verify necessary Shotgun custom fields exist on Version entity (only checking for sg_path_to_geometry)
        version_schema = self.sg.schema_field_read("Version")
        if "sg_path_to_geometry" not in version_schema:
            raise Exception("sg_path_to_geometry field undefined in Version entity.")
        
        # Base filters: Always filter by project and existing geometry path
        filters = [
            ["project", "is", {"type": "Project", "id": self.HAL_PROJECT_SGID}],
            ["sg_path_to_geometry", "is_not", None]
        ]
        
        # Fields to retrieve from Shotgun
        # We need 'entity.type' (Asset/Shot) for entity-specific filtering.
        # We also need 'entity.Asset.sg_asset_type' if your Asset entity has such a field.
        # And 'entity.Shot.sg_sequence' for Shot filtering.
        fields = [
            "id", "code", "sg_path_to_geometry", "image", "entity",
            "entity.Shot.sg_sequence",        # Assuming your Shot entity has a 'sg_sequence' field
            "entity.Asset.sg_asset_type",     # IMPORTANT: Assuming your Asset entity has a 'sg_asset_type' field
                                              # If not, this field will be None or you need to remove it.
        ]

        # Add context-based filtering if provided
        if tab_context:
            print(f"Applying Shotgun filters based on context: {tab_context}")
            try:
                type_part, category_part = tab_context.split('/') # Example: "mdl", "props" or "anim", "0010"

                # Define known type parts for Assets and Shots
                asset_version_types = ["mdl", "shd", "rig", "txt", "cgfx-setup", "cncpt"]
                shot_version_types = ["anim", "cgfx", "comp", "layout", "lgt", "mm", "matp", "paint", "roto"]
                
                # Use a combined filter for 'code' that helps narrow down based on type_part
                # and abbreviation for asset categories.
                code_filters = [] # This list will hold simple list-style filters

                if type_part in asset_version_types:
                    # 正确的 Asset 类型过滤
                    filters.append(["entity", "type_is", "Asset"])
                    
                    # Try to filter by Asset's 'sg_asset_type' field (if it exists and is used)
                    # IMPORTANT: 'sg_asset_type' needs to be a real field on your Shotgun Asset entity.
                    # And 'category_part' (e.g., 'props') needs to match its value (e.g., 'Prop' or 'Props').
                    # You might need to adjust 'category_part.capitalize()' or similar.
                    # Check your Asset entity schema in Shotgun to confirm the field name and values.
                    # For example, if your Asset type field is 'sg_type' and values are 'Prop', 'Vehicle':
                    # filters.append(["entity.Asset.sg_type", "is", category_part.capitalize()])
                    
                    # If no specific Asset type field, fall back to 'code' contains for abbreviation
                    abbreviation = self._get_category_abbreviation(category_part)
                    if abbreviation:
                        # Changed to list format
                        code_filters.append(["code", "contains", abbreviation])
                    
                    # Also add the type_part (mdl, rig, etc.) to code filter
                    # Changed to list format
                    code_filters.append(["code", "contains", type_part])
                    
                elif type_part in shot_version_types:
                    # 正确的 Shot 类型过滤
                    filters.append(["entity", "type_is", "Shot"])
                    
                    # Filter by Shot's sequence field
                    # 'category_part' here is expected to be the sequence code (e.g., "0010")
                    # We need to find the Sequence entity by its code and use its ID for filtering
                    sequence_entity = self.sg.find_one(
                        "Sequence", 
                        [["project", "is", {"type": "Project", "id": self.HAL_PROJECT_SGID}], ["code", "is", category_part]],
                        ["id"]
                    )
                    
                    if sequence_entity:
                        filters.append(["entity.Shot.sg_sequence", "is", {"type": "Sequence", "id": sequence_entity["id"]}])
                    else:
                        print(f"Warning: Sequence with code '{category_part}' not found in Shotgun. Skipping sequence filter.")
                        # Optionally, you might want to raise an error or return an empty list here
                        # if finding the sequence is critical for the query.
                    
                    # Also add the type_part (anim, comp, etc.) to code filter
                    # Changed to list format
                    code_filters.append(["code", "contains", type_part])

                else:
                    print(f"Warning: Unknown type_part '{type_part}' in context '{tab_context}'. Filtering only by code contains.")
                    # Fallback for unknown type_part: just search 'code' for both parts
                    # Changed to list format
                    code_filters.append(["code", "contains", type_part])
                    code_filters.append(["code", "contains", category_part])

                # Combine code filters with AND logic if multiple.
                # If only one, just append it. If more, wrap in proper filter structure
                if len(code_filters) == 1:
                    filters.append(code_filters[0])
                elif len(code_filters) > 1:
                    filters.append({
                        "filter_operator": "and",
                        "conditions": code_filters,  # Now code_filters contains list-style filters
                        "filters": code_filters      
                    })


            except ValueError:
                # Handle single-part context (e.g., "anim")
                print(f"Warning: Single-part context '{tab_context}' received. Filtering by code contains the context name.")
                # Assumes single part context implies a version type (e.g., "anim")
                filters.append(["code", "contains", tab_context])
                
            except Exception as e:
                print(f"Error building Shotgun filters for context '{tab_context}': {e}")
                import traceback
                traceback.print_exc()
                # Fallback to no context filtering if error occurs, or raise error
        
        # Perform the Shotgun query with all built filters

        print(f"filters is:{filters}")
        print(f"fields is{fields}")

        versions = self.sg.find("Version", filters, fields)

        print(f"Found {len(versions)} versions with geometry paths after Shotgun filtering.")

        # --- 新增/修改逻辑：将 sg_path_to_geometry 从字符串转换为列表 ---
        # Shotgun API返回的自定义多行文本字段，即使存储的是Python列表字符串，也会是字符串类型。
        # 我们需要将其解析为真正的Python列表。
        for version in versions:
            geo_path_field = version.get('sg_path_to_geometry')
            if isinstance(geo_path_field, str):
                try:
                    # 尝试将字符串解析为Python列表
                    parsed_list = ast.literal_eval(geo_path_field)
                    if isinstance(parsed_list, list):
                        version['sg_path_to_geometry'] = parsed_list
                    else:
                        # 如果解析后不是列表，说明它不是预期的列表字符串，
                        # 则将其视为单个路径，并放入列表中。
                        version['sg_path_to_geometry'] = [geo_path_field]
                except (ValueError, SyntaxError) as e:
                    # 如果解析失败（例如，它不是一个合法的Python列表字符串，或包含错误语法），
                    # 则将其视为单个路径，并放入列表中。
                    print(f"Warning: Failed to parse sg_path_to_geometry string '{geo_path_field}' for version {version.get('code')}: {e}")
                    version['sg_path_to_geometry'] = [geo_path_field]
            elif geo_path_field is None:
                version['sg_path_to_geometry'] = [] # 如果是 None，设置为空列表
            # 如果 geo_path_field 已经是列表类型，则不需要处理
        # --- 结束新增/修改逻辑 ---

        # Group versions by (entity_type, entity_id, category) and keep only highest version
        # This client-side deduplication is still important for showing only unique latest versions.
        latest_versions = {}
        for version in versions:
            self._categorize_version(version) # This populates version["category"] from 'code'
            entity = version.get("entity", {})
            
            # Key ensures a single highest version per entity AND per recognized category (mdl, rig, anim etc.)
            key = (entity.get("type"), entity.get("id"), version.get("category")) 
            
            current_version_num = self._get_version_number(version.get("code", ""))
            existing_version_num = self._get_version_number(latest_versions.get(key, {}).get("code", ""))
            
            if key not in latest_versions or current_version_num > existing_version_num:
                latest_versions[key] = version

        # Process only the latest versions (which are already highly filtered by Shotgun)
        print(f"Filtered to {len(latest_versions)} latest versions (highest per category within the context).")
        for version in latest_versions.values():
            print(f"Processing latest version: {version.get('code')}")
            version["image"] = self.extract_filename_from_url(version.get("image"))
            self._print_version_paths(version)
        
        versions = list(latest_versions.values())
        
        if not versions:
            print("No versions found with geometry paths for the given context.")
        
        return versions

    def _print_version_paths(self, version: Dict):
        """Print full version name, geo path and thumbnail path"""
        print(f"Version Name: {version.get('code', 'N/A')}")
        # 这里打印的是 sg_path_to_geometry 的原始值，现在它可能是一个列表
        print(f"Geometry Path: {version.get('sg_path_to_geometry', 'N/A')}") 
        print(f"Thumbnail Path: {version.get('image', 'N/A')}")
        print("-" * 50)

