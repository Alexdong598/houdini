"""Main submission functions."""

# Import third-party modules
# from hal_ontrack import track_dependencies_in_houdini
# from hal_ontrack.apps.houdini_funcs import track_dependencies

# Import local modules
from houdini_deadline_api_submission import utils
from houdini_deadline_api_submission.job.base import BaseDeadlineJob
from houdini_deadline_api_submission.job.render import ArnoldDeadlineJob
from houdini_deadline_api_submission.job.render import MantraDeadlineJob
from houdini_deadline_api_submission.job.render import FetchDeadlineJob

_CLASS_LOOKUP = {
    "ifd": MantraDeadlineJob,
    "arnold": ArnoldDeadlineJob,
    "usdrender_rop": FetchDeadlineJob,
}

def setup_fxcache_networks(nodes):
    """Re-Build any FXCache ROP Networks that are present in the given nodes.

    Args:
        nodes (:obj:`list` of :obj:`hou.Node`): Submitted nodes that will be
            checked for any FXCache parent.

    """
    fxcache_nodes = set()
    for node in nodes:
        while node.parent():
            if node.type().nameComponents()[2] == "fxcache_ex":
                fxcache_nodes.add(node)
            node = node.parent()

    for node in fxcache_nodes:
        node.parm("setup_rop").pressButton()


def get_jobs(base_node, submitter_node=None):
    """Get jobs of the given node.

    Args:
        base_node (hou.Node): Base node to collect the jobs from.
        submitter_node (hou.Node): HAL Deadline Submit ROP that is being used
            to drive the submission.

    Returns:
        :obj:`list` of :obj:`houdini_deadline_api_submission.deadline_job.BaseDeadlineJob`:
            Jobs created by going up the dependency chain of the given node.

    """
    timestamp = utils.get_timestamp()
    dependency_tree = utils.get_dependency_tree(base_node)

    # Set-Up all FXCache ROP Networks before retrieving the tree again, so we
    # can be sure that all of them are up to date.
    nodes = [leaf["node"] for leaf in dependency_tree]
    setup_fxcache_networks(nodes)
    dependency_tree = utils.get_dependency_tree(base_node)

    # Track the jobs outputs as Published Files in Shotgun.
    tracker = None
    # if track_dependencies_in_houdini():
    #     tracker = track_dependencies()

    jobs = []
    for leaf in dependency_tree:
        node = leaf["node"]
        dependency_ids = leaf["dependency_ids"]
        dependent_jobs = [jobs[id_] for id_ in dependency_ids]

        # Choose constructor based on lookups defined in _CLASS_LOOKUP.
        constructor = BaseDeadlineJob
        for node_type in _CLASS_LOOKUP:
            if node_type in node.type().nameComponents():
                constructor = _CLASS_LOOKUP[node_type]
                break

        job = constructor(
            node,
            dependent_jobs,
            submitter_node=submitter_node,
            timestamp=timestamp,
            tracker=tracker,
        )
        jobs.append(job)
    return jobs


def submit(base_node, submitter_node=None):
    """Submit all of the nodes connected to the base_node.

    Args:
        base_node (hou.Node): Node to submit.
        submitter_node (hou.Node): HAL Deadline Submit ROP that is being used
            to drive the submission.

    Returns:
        list of int: Deadline IDs of submitted jobs.

    """
    jobs = get_jobs(base_node, submitter_node)
    for job in jobs:
        job.submit_all()

    submitted_ids = []
    for base_job in jobs:
        for job in base_job.get_flattened_jobs():
            submitted_ids.append(job.deadline_id)

    return submitted_ids
