"""Base class for all Deadline jobs."""

# Import built-in modules
import copy
import logging
import os

# Import third-party modules
import hou  # pylint: disable=import-error

# Import local modules
from houdini_deadline_api_submission import config
from houdini_deadline_api_submission import constants
from houdini_deadline_api_submission import deadline_utils
from houdini_deadline_api_submission import naming
from houdini_deadline_api_submission import utils
from houdini_deadline_api_submission import wedging
import houdini_deadline_api_submission.parm_utils


# TODO This class has way too many functions and concerns. Splitting this up is a must.
# TODO We should use the deadline_api_submission package in this class.
class BaseDeadlineJob(object):
    """Deadline Job generated by Houdini."""

    def __init__(
        self,
        node,
        dependencies,
        submitter_node=None,
        plugin_name=constants.HOUDINI_PLUGIN,
        job_info_overrides=None,
        plugin_info_overrides=None,
        wedge_values=None,
        wedge_index=None,
        output_parm_name=None,
        node_parm_overrides=None,
        save_copy=None,
        timestamp=None,
        tracker=None,
    ):
        """The base class of any Deadline Job.

        This class is meant to be used for 90% of the ROPs, while the rest, for
        example a Mantra ROP, need their own class which inherits from this one
        and overrides the pre_submit_all method to adjust the jobs that will be
        submitted and the post_submit_all method to do any cleanup or whatever
        needs to be done after the submission.

        Args:
            node (hou.Node): Node to turn into a job.
            dependencies (:obj:`list` of :obj:`BaseDeadlineJob`): List of all
                jobs this job depends on to be able to successfully run.
            plugin_name (str): Name of the Deadline Plugin to use.
            job_info_overrides (dict, optional): Values in this dictionary
                will override any job info values queried from the node.
            plugin_info_overrides (dict, optional): Values in this dictionary
                will override any plugin info values queried from the node.
            wedge_values (list, optional): Parameters to wedge and their wedged
                value.
            wedge_index (int, optional): Index of the given wedge.
            output_parm_name (str, optional): Name of the output parameter.
                This is used to set the OutputDirectory0 and OutputFilename0
                parameter on submission.
            node_parm_overrides (dict, optional): Overrides that will adjust
                parameters on the node when submitting, and will reset these
                parameters to their previous value after submitting this job.
            save_copy (bool, optional): If True, a copy of the Houdini file
                will be saved and stored in the jobs 'SceneInputFile'. Defaults
                to True.
            timestamp (str, optional): The timestamp that will be used for
                various operations in this job. If no timestamp is given, a
                timestamp with the current time will be used.
            tracker (hal_ontrack.tracker.Tracker): The Tracker instance that got
                created.

        """
        if not job_info_overrides:
            job_info_overrides = {}
        if not plugin_info_overrides:
            plugin_info_overrides = {}
        if save_copy is None:
            save_copy = plugin_name == constants.HOUDINI_PLUGIN
        if not timestamp:
            timestamp = utils.get_timestamp()

        # Assign basic parameters.
        self.node = node
        self.dependencies = dependencies
        self.add_as_dependency = True
        self.jobs = [self]
        self.deadline_id = None
        self.is_submitted = False
        self.job_info = {}
        self.plugin_info = {}
        self.tracker = tracker
        self.wedge_values = wedge_values
        self.wedge_index = wedge_index
        self.is_wedge = wedge_values and wedge_index is not None
        self.submitter_node = submitter_node
        self.output_parm = naming.get_output_parm(node, output_parm_name)
        self.pre_submit_parm_states = {}
        self.submit_parm_overrides = node_parm_overrides if node_parm_overrides else {}
        self.timestamp = timestamp
        self.do_save_copy = save_copy
        self.dry_run = bool(self.submitter_node.parm("dry_run").eval())
        if all((self.dry_run, not self.submitter_node.parm("save_submit_file").eval())):
            self.do_save_copy = False

        # If this is a PrePass Node, mark it as such.
        self.is_pre_pass = utils.is_pre_pass(node)

        # Adjust data based on config, overrides, and wedges.
        self.plugin_info["IgnoreInputs"] = True
        self.plugin_info["FrameByFrame"] = True
        self.apply_config()
        self.apply_hda_settings()
        self.apply_node_overrides()
        self.apply_overrides(job_info_overrides, plugin_info_overrides)
        self.job_info["Plugin"] = plugin_name
        self.job_info["UserName"] = naming.get_username()
        self.job_info["LimitGroups"] = "houdini_hbatch"
        self.plugin_info["OutputDriver"] = node.path()
        self.plugin_info["Version"] = hou.applicationVersionString()
        self.get_frames()
        self.get_outputs()
        self.set_batch_name()

        # When no wedge values are given, we have to create the wedged jobs. If
        # there are no wedged jobs, this will just return the job object
        # itself.
        if not self.is_wedge:
            self.jobs = self.jobs_from_wedges()

        # Check the dependencies and correct them if need be. This is needed in
        # cases where the parent job has more than one job (through wedging, or
        # any other means), and will also take care of cleaning up PrePass
        # jobs from the dependencies.
        self.set_all_dependencies()

        if plugin_name != constants.HOUDINI_PLUGIN:
            self.plugin_info = copy.copy(plugin_info_overrides)

        if self.is_pre_pass:
            self.submit_all()

    def set_batch_name(self):
        """Set the batch name of this job."""
        self.job_info["BatchName"] = "{} ({})".format(
            hou.hipFile.basename(), self.timestamp
        )

    def get_outputs(self):
        """Set the output values of this job."""
        try:
            self.job_info["OutputDirectory0"] = os.path.dirname(
                self.output_parm.evalAsString()
            )
            self.job_info["OutputFilename0"] = os.path.basename(
                self.output_parm.evalAsString()
            )
        except AttributeError:
            logger = logging.getLogger(__name__)
            logger.info(
                "Could not get the output parameter of %s. Does it "
                "have a filename parameter?",
                self.node.path(),
            )

    def apply_hda_settings(self):
        """Apply overrides defined in the node that is submitting this job."""
        if self.submitter_node:
            self.apply_overrides(
                houdini_deadline_api_submission.parm_utils.get_job_info(
                    self.submitter_node, goal_node=self.node
                ),
                houdini_deadline_api_submission.parm_utils.get_plugin_info(
                    self.submitter_node, goal_node=self.node
                ),
            )

    def apply_node_overrides(self):
        """Apply override defined in the submitted node."""
        self.apply_overrides(
            houdini_deadline_api_submission.parm_utils.get_job_info(self.node),
            houdini_deadline_api_submission.parm_utils.get_plugin_info(self.node),
        )

    def apply_config(self):
        """Apply overrides defined in the config via a config yaml file."""
        self.apply_overrides(
            config.get_config("job_info") or {}, config.get_config("plugin_info") or {}
        )

    def apply_overrides(self, job_info_overrides, plugin_info_overrides):
        """Apply the given overrides to this object.

        Args:
            job_info_overrides (dict): Overrides for job parameters.
            plugin_info_overrides (dict): Overrides for plugin parameters.

        """
        self.job_info.update(job_info_overrides)
        self.plugin_info.update(plugin_info_overrides)

    def get_frames(self):
        """Get the frames from the ROP and set them in the job_dict."""
        start, end, inc = utils.get_frames(self.node)
        self.job_info["Frames"] = deadline_utils.get_framestring(start, end, inc)

    def jobs_from_wedges(self):
        """Create jobs from wedges.

        Returns:
            :obj:`list` of :obj:`BaseDeadlineJob`: Jobs with wedge information.

        """
        wedges = wedging.get_wedges(self.node)
        if not wedges:
            return [self]
        wedged_jobs = []
        for wedge_index, wedge in enumerate(wedges):
            wedged_jobs.append(
                BaseDeadlineJob(
                    node=self.node,
                    dependencies=self.dependencies,
                    submitter_node=self.submitter_node,
                    job_info_overrides=self.job_info,
                    plugin_info_overrides=self.plugin_info,
                    wedge_values=wedge,
                    wedge_index=wedge_index,
                    output_parm_name=self.output_parm,
                    save_copy=self.do_save_copy,
                    timestamp=self.timestamp,
                )
            )
        return wedged_jobs

    def add_dependency(self, job):
        """Add a job as a dependency.

        Args:
            job (BaseDeadlineJob): Job to add as a dependency.

        """
        if job not in self.dependencies:
            self.dependencies.append(job)

    def log(self, message, indent=0, log_parm_name=constants.LOG_PARM):
        """Log a message onto the node.

        Args:
            message (str): Message to add to the log.
            indent (int, optional): Indent of the logged message. Defaults to
                0.
            log_parm_name (str, optional): Name of the logging parm. Defaults
                to constants.LOG_PARM.

        """
        try:
            utils.log_message(
                self.node, message, indent=indent, log_parm_name=log_parm_name
            )
        except hou.PermissionError:
            logger = logging.getLogger(__name__)
            logger.debug(
                "Logging to node %s was not possible because it "
                "is inside a locked asset.",
                self.node.path(),
            )

    def get_flattened_jobs(self):
        """Return a flattened list of all jobs which will be sent to the farm.

        Returns:
            :obj:`list` of :obj:`BaseDeadlineJob`: All jobs coming from this
                job.

        """
        all_jobs = []
        if len(self.jobs) == 1:
            return self.jobs
        for job in self.jobs:
            all_jobs += job.get_flattened_jobs()
        return all_jobs

    @staticmethod
    def correct_pre_pass_dependencies(dependencies):
        """Set dependencies to the first Non-PrePass job found.

        Args:
            dependencies (:obj:`list` of :obj:`BaseDeadlineJob`): Jobs used as
                dependencies.

        Returns:
            :obj:`list` of :obj:`BaseDeadlineJob`: Jobs without any PrePass
                jobs. PrePass jobs are replaced by their own dependencies.

        """
        # Clean up PrePass dependencies by going up in the dependency chain and
        # taking the first Non-PrePass entry.
        new_dependencies = []
        for job in dependencies:
            if job.is_pre_pass:
                new_dependencies.append(
                    BaseDeadlineJob.correct_pre_pass_dependencies(job.dependencies)
                )
            else:
                new_dependencies.append(job)

        # Clear out empty dependencies.
        return [dep for dep in new_dependencies if dep]

    def correct_wedge_dependencies(self):
        """Set dependencies based on wedge likeness.

        Jobs with the exact same wedge values can depend on only this wedge,
        rather than every wedge being finished.

        """
        if not self.is_wedge:
            return

        new_dependencies = []
        for other_main_job in self.dependencies:
            for other_job in other_main_job.get_flattened_jobs():
                if not other_job.is_wedge:
                    continue

                if self.wedge_values == other_job.wedge_values:
                    new_dependencies.append(other_job)

        if new_dependencies:
            self.dependencies = new_dependencies

    def set_all_dependencies(self):
        """Set dependencies of this job.

        It's possible for the dependencies to have generated more jobs. In this
        case, we need to make sure we depend on all jobs being finished to
        actually continue. This also fixes any dependencies on PrePass jobs.

        It's also possible to have the same amount of wedges. In this case, it
        might be wanted to match each wedge to it's corresponding wedge
        dependency. This is only done when 'HAL_dl_depend_on_same_wedge' is
        turned on and the amount of wedges created match each other.

        """
        self.dependencies = self.correct_pre_pass_dependencies(self.dependencies)
        self.correct_wedge_dependencies()

    def apply_wedges(self):
        """Apply the wedged values to all of the wedged parameters."""
        if not self.is_wedge:
            return

        wedging.apply_wedge(self.wedge_values, self.wedge_index)

        # Add the WEDGE and WEDGENUM variable to the job info dict.
        deadline_utils.append_to_deadline_env(
            self.job_info, "WEDGE", hou.getenv("WEDGE")
        )
        deadline_utils.append_to_deadline_env(
            self.job_info, "WEDGENUM", hou.getenv("WEDGENUM")
        )

        # Update Comment.
        submitter_dict = houdini_deadline_api_submission.parm_utils.get_job_info(
            self.submitter_node, self.node
        )
        node_dict = houdini_deadline_api_submission.parm_utils.get_job_info(
            self.submitter_node, self.node
        )
        submitter_dict.update(node_dict)
        if "Comment" in submitter_dict:
            self.job_info["Comment"] = submitter_dict["Comment"]

        # Add Wedge to Name.
        self.job_info["Name"] = "{} - {}".format(
            self.job_info["Name"], hou.getenv("WEDGE")
        )

    def reset_wedging(self):
        """Reset the wedged parameters to the value they were before."""
        if self.is_wedge:
            wedging.reset_wedging()

    def save_copy(self):
        """Save a copy of the file to the current output path."""
        if not self.do_save_copy:
            return

        if self.output_parm:
            path = os.path.dirname(self.output_parm.evalAsString())
            path = os.path.join(path, "_deadline")
        else:
            path = os.path.dirname(hou.hipFile.path())
            path = os.path.join(path, "_deadline", self.node.name())
        path = utils.save_copy(path)
        self.plugin_info["SceneFile"] = path

    def submit_all(self):
        """Start the submission process of all the jobs created by this job.

        This method runs the pre- and post- operations of the 'submit_all'
        category, which includes the log creation on the node. Therefore,
        submissions should always be started with this method.

        """
        if self.is_submitted:
            return

        self.pre_submit_all()
        self._submit()
        self.post_submit_all()
        self.is_submitted = True

    def _submit(self):
        """Submit each job created by this job."""
        # A job object can hold more than one job. We only want to _submit each
        # job on it's own though, to make sure jobs gets submitted in the right
        # order and following their dependencies.
        for job in self.get_flattened_jobs():
            job._submit_job()

    def _submit_job(self):
        """Submit this singular job to Deadline."""
        # TODO Save HIP, HIPNAME, HIPFILE, JOB into Deadline Environemnt Variables.
        # TODO Set HOUDINI_HIP_FROM_PATH to 0, so it won't update the Environment Variables.
        # TODO Use hou.allowEnvironmentToOverwriteVariable() on JOB, ... to allow overrides.
        # TODO Add a checkbox to the node that will copy the HOME folder to a temp submission
        #      folder and set the HOME variable to this path. That way, we can make sure that
        #      local overrides like the max size of CHOP operations is also taken into
        #      consideration.
        self.pre_submit()
        self.apply_wedges()

        if self.is_pre_pass:
            if not self.dry_run:
                self.node.render(ignore_inputs=True)
                self.deadline_id = "PrePass: {}".format(self.node.path())
        else:
            self.save_copy()
            if self.dry_run:
                self.bake_dependencies()
                print(str(self))
            else:
                self.bake_dependencies()
                self.deadline_id = deadline_utils.submit_job(
                    self.job_info, self.plugin_info
                )
        self.reset_wedging()
        self.post_submit()

    def pre_submit_all(self):
        """Store a log entry.

        This method is designed to be overwritten via another class. It will
        run before starting the submission process and is intended for
        adjustments like:
            - Creating new jobs stored in self.jobs.
            - Adjusting job settings stored in self.job_info.
            - Adjusting plugin settings stored in self.plugin_info.
            - Creating more detailed log-entries.

        """
        self.log("Started submission: {}".format(utils.get_timestamp()))

    def post_submit_all(self):
        """Store a log entry.

        This method is designed to be overwritten via another class. It will
        run after the submission process is finished and is intended for
        adjustments like:
            - Creating more detailed log-entries.
            - Providing user feedback.

        """
        self.log("Submission successfully finished: {}".format(utils.get_timestamp()))

    def pre_submit(self):
        """Run functions before submitting a singular job.

        This method is designed to be extended via another class. It will
        run before the submission of a singular job - right before the wedges
        are applied - and is intended for adjustments like:
            - Creating more detailed log-entries.
            - Adjusting certain values on the ROP stored in self.node.

        """
        if self.submit_parm_overrides:
            try:
                old_values = {
                    name: self.node.parm(name).eval()
                    for name in self.submit_parm_overrides
                }
                self.node.setParms(self.submit_parm_overrides)
                self.pre_submit_parm_states = old_values
            except hou.OperationFailed:
                pass

        try:
            parm = self.node.parm("trange")
            if parm and parm.eval() == 1:
                parm.set(2)
        except hou.OperationFailed:
            pass

        # If the frame range is set to current frame, set it to Frame Range
        # (Strict) instead.
        start, end, _ = utils.get_frames(self.node)
        if start == end and self.node.parm("trange"):
            try:
                old_values = {
                    "trange": self.node.evalParm("trange"),
                    "f1": self.node.evalParm("f1"),
                    "f2": self.node.evalParm("f2"),
                }
                new_values = {"trange": 2, "f1": start, "f2": end}
                self.node.setParms(new_values)
                self.pre_submit_parm_states.update(old_values)
            except hou.OperationFailed:
                pass

    def post_submit(self):
        """Run functions after submitting a singular job.

        This method is designed to be extended via another class. It will
        run after the submission of a singular job - right after the wedges are
        reset - and is intended for adjustments like:
            - Creating more detailed log-entries.
            - Adjusting certain values on the ROP stored in self.node.

        """
        self.node.setParms(self.pre_submit_parm_states)

    def bake_dependencies(self):
        """Add any job declared as a dependency to the Deadline Job Info."""
        job_index = 0
        for master_job in self.dependencies:
            for job in master_job.get_flattened_jobs():
                if job.add_as_dependency:
                    self.job_info["JobDependency{}".format(job_index)] = job.deadline_id
                    job_index += 1

    def __str__(self, indent=0):
        """Return a string representation of this job.

        Args:
            indent (int, optional): The amount of space put in front of the
                message.

        Returns:
            str: String representation of this job.

        """
        msg = [
            "{indent}{node}: {path}",
            "{indent}Wedge: {wedge}",
            "{indent}Dependencies:",
            "{dependencies}",
            "{indent}---",
        ]
        if not self.is_wedge:
            msg.pop(1)

        msg = "\n".join(msg)

        str_indent = " " * indent
        str_wedge = []
        if self.wedge_values:
            for wedge_config in self.wedge_values:
                str_wedge.append(
                    "{}({}): {}".format(
                        wedge_config[0], wedge_config[1], wedge_config[2]
                    )
                )
        str_wedge = " - ".join(str_wedge)
        dep_str = "\n".join((job.__str__(indent + 2) for job in self.dependencies))

        msg = msg.format(
            indent=str_indent,
            node=self.node.name(),
            path=self.node.path(),
            cls=self.__class__.__name__,
            wedge=str_wedge,
            dependencies=dep_str,
        )

        return msg

    def __repr__(self):
        """Return a string that can be used to recreate the job object.

        Returns:
            str: Executable string that can be used to recreate the job object.

        """
        output_parm = self.output_parm.name() if self.output_parm else None
        return (
            "houdini_deadline_api_submission.deadline_job.%s("
            "node=hou.node(%r), dependencies=%r, submitter_node=%r, "
            "plugin_name=%r, job_info_overrides=%r, "
            "plugin_info_overrides=%r, wedge_values=%r, wedge_index=%r, "
            "output_parm_name=%r)"
            % (
                self.__class__.__name__,
                self.node.path(),
                self.dependencies,
                self.submitter_node,
                self.job_info["Plugin"],
                self.job_info,
                self.plugin_info,
                self.wedge_values,
                self.wedge_index,
                output_parm,
            )
        )

    def __eq__(self, other):
        """Compare two jobs to each other to see if they are equal.

        Args:
            other (BaseDeadlineJob): The job to compare it to.

        Returns:
            bool: True if the two jobs are the same, False otherwise.

        """
        if not isinstance(other, self.__class__):
            return False

        same_parms = all(
            (
                self.node == other.node,
                self.job_info == other.job_info,
                self.plugin_info == other.plugin_info,
                self.wedge_values == other.wedge_values,
                self.wedge_index == other.wedge_index,
                self.output_parm == other.output_parm,
                self.submitter_node == other.submitter_node,
            )
        )
        if not same_parms:
            return False
        for this_dependency, other_dependency in zip(
            self.dependencies, other.dependencies
        ):
            if this_dependency.node != other_dependency.node:
                return False
        for this_job, other_job in zip(self.jobs, other.jobs):
            if this_job.wedge_index != other_job.wedge_index:
                return False
            if this_job.wedge_values != other_job.wedge_values:
                return False
        return True

    def __ne__(self, other):
        """Compare two jobs to each other to see if they are not equal.

        Args:
            other (BaseDeadlineJob): The job to compare it to.

        Returns:
            bool: True if the two are different, False otherwise.

        """
        return not self.__eq__(other)
