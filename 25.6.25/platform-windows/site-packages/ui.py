import importlib
import sys
from PySide2 import QtWidgets, QtCore, QtGui
import os 
import ast

def get_command():
    def _command():
        try:
            window = ShotgunLibraryUI()
            window.show()
        except Exception as e:
            print(f"Failed: {str(e)}")
    return _command

_window_instance = None

def execute():
    global _window_instance
    importlib.reload(sys.modules[__name__])
    
    if _window_instance:
        try:
            _window_instance.close()
            _window_instance = None 
        except Exception as e:
            print(f"Warning: Could not close previous window instance: {e}")
            pass
    
    try:
        _window_instance = ShotgunLibraryUI()
        _window_instance.setAttribute(QtCore.Qt.WA_DeleteOnClose, False) 
        _window_instance.show()
        return _window_instance
    except Exception as e:
        print(f"Failed to create window: {str(e)}")
        raise

class ShotgunLibraryUI(QtWidgets.QWidget):
    """Main UI window for Shotgun Library."""
    
    ASSET_TYPES = ["mdl", "shd", "rig", "txt", "cgfx-setup", "cncpt"]
    SHOT_TYPES = ["anim", "cgfx", "comp", "layout", "lgt", "mm", "matp", "paint", "roto"]
    
    HAL_CATEGORY_TYPES = ["cgfx", "characters", "environments", "props", "vehicles"]
    
    def __init__(self):
        super(ShotgunLibraryUI, self).__init__()
        self.setWindowTitle("Shotgun Library")
        self.resize(1200, 600) 
        
        try:
            from shotgun_data_manager import ShotgunDataManager
            self.data_manager = ShotgunDataManager()
        except ImportError:
            print("Error: Could not import ShotgunDataManager. Make sure 'shotgun_data_manager.py' is accessible.")
            class DummyDataManager:
                def find_files(self):
                    print("DummyDataManager: Returning dummy data.")
                    # Adding a dummy entry that matches the 'rig/vehicles' context for testing
                    return [
                        {"id": 1, "code": "mdl_char_hero_v001", "sg_path_to_geometry": "X:/project/assets/characters/hero/mdl/hero_v001.mb", "image": "thumb_hero", "entity": {"type": "Asset", "id": 101, "name": "char_hero"}, "category": "mdl", "sg_category": "characters"},
                        {"id": 2, "code": "rig_prop_lamp_v002", "sg_path_to_geometry": "X:/project/assets/props/lamp/rig/lamp_v002.mb", "image": "thumb_lamp", "entity": {"type": "Asset", "id": 102, "name": "prop_lamp"}, "category": "rig", "sg_category": "props"},
                        {"id": 3, "code": "anim_shot010_v001", "sg_path_to_geometry": "X:/project/shots/shot010/anim/shot010_v001.ma", "image": "thumb_shot", "entity": {"type": "Shot", "id": 201, "name": "shot010"}, "category": "anim"},
                        # This entry is specifically for the 'rig/vehicles' test case
                        {"id": 4, "code": "rig_veh_benz_v085", "sg_path_to_geometry": "X:/pipelinernd_rnd-0192/_library/assets/vehicles/veh_benz/rig/_publish/rnd_veh_benz_rig_v085_yud.mb", "image": "rnd_veh_benz_rig_v085_yud_temp", "entity": {"type": "Asset", "id": 103, "name": "veh_benz"}, "category": "rig", "sg_category": "vehicles"}
                    ]
            self.data_manager = DummyDataManager()
        
        self.dynamic_tab_content_cache = {} 
        
        self.setup_ui()
        self._update_bottom_tabs(self.top_tab_bar.currentIndex()) 
        
    def setup_ui(self):
        """Create and arrange UI components."""
        self.main_h_layout = QtWidgets.QHBoxLayout(self) 
        
        self.left_panel_v_layout = QtWidgets.QVBoxLayout() 
        
        self.top_tab_bar = QtWidgets.QTabBar()
        self.top_tab_bar.addTab("Assets")
        self.top_tab_bar.addTab("Shots")
        self.top_tab_bar.currentChanged.connect(self._update_bottom_tabs)
        
        self.bottom_tab_widget = QtWidgets.QTabWidget()
        
        controls_layout = QtWidgets.QHBoxLayout()
        self.refresh_btn = QtWidgets.QPushButton("Refresh")
        self.close_btn = QtWidgets.QPushButton("Close")
        
        controls_layout.addWidget(self.refresh_btn)
        controls_layout.addStretch() 
        controls_layout.addWidget(self.close_btn)
        
        self.left_panel_v_layout.addWidget(self.top_tab_bar)
        self.left_panel_v_layout.addWidget(self.bottom_tab_widget)
        self.left_panel_v_layout.addLayout(controls_layout)
        
        self.options_widget = QtWidgets.QWidget() 
        self.setup_options_panel(self.options_widget) 
        
        self.main_h_layout.addLayout(self.left_panel_v_layout, 2) 
        self.main_h_layout.addWidget(self.options_widget, 1) 
        
        self.close_btn.clicked.connect(self.close)
        self.refresh_btn.clicked.connect(self._handle_refresh)
        
    def _handle_refresh(self):
        """Handle refresh button click - fetch and display Shotgun data"""
        try:
            versions = self.data_manager.find_files()
            
            current_tab = self.bottom_tab_widget.currentWidget()
            tab_context = ""
            if current_tab:
                tab_index = self.bottom_tab_widget.currentIndex()
                tab_name = self.bottom_tab_widget.tabText(tab_index)
                
                if isinstance(current_tab, QtWidgets.QTabWidget):
                    inner_tab = current_tab.currentWidget()
                    inner_index = current_tab.currentIndex()
                    inner_name = current_tab.tabText(inner_index)
                    tab_context = f"{tab_name}/{inner_name}"
                else:
                    tab_context = tab_name
            
            print(f"\nCurrent context: {tab_context}")
            print("{:<15} | {:<80} | {:<30}".format(
                "Version", "Geometry Path", "Image"
            ))
            print("-" * (15 + 3 + 80 + 3 + 30))
            
            CATEGORY_ABBREVIATIONS = {
                'characters': 'chr',
                'environments': 'env', 
                'props': 'prp',
                'vehicles': 'veh',
                'cgfx': 'cgfx'
            }
            
            filtered_versions = []
            # print(f"\nDebug - Raw versions data:")
            # for v in versions:
            #     print(f"Code: {v.get('code')}, Category: {v.get('category')}, SG_Category: {v.get('sg_category')}")
            
            for v in versions:
                # --- NEW LOGIC TO CALCULATE IMAGE PATH ---
                geo_path = v.get('sg_path_to_geometry')
                image_prefix = v.get('image') # This is the "old image file name" / prefix from Shotgun

                calculated_image_path = None # Default to None (missing/error)

                if geo_path and image_prefix:
                    # Get the directory name from the geometry path
                    dirname = os.path.dirname(geo_path)
                    # Construct the potential thumbnail folder path
                    thumbnail_folder = os.path.join(dirname, "_SGthumbnail") 

                    if os.path.isdir(thumbnail_folder): # Check if the thumbnail folder exists
                        matching_files = []
                        try:
                            for filename in os.listdir(thumbnail_folder):
                                # Check if the filename starts with the given image prefix
                                if filename.startswith(image_prefix):
                                    matching_files.append(filename)
                        except OSError as e:
                            print(f"Warning: Could not list directory {thumbnail_folder} due to {e}")
                            
                        if len(matching_files) == 1:
                            # If exactly one match, construct the full path
                            calculated_image_path = os.path.join(thumbnail_folder, matching_files[0])
                        elif len(matching_files) > 1:
                            print(f"Warning: Multiple image files found for prefix '{image_prefix}' in '{thumbnail_folder}'. Thumbnail will not be displayed.")
                        # else: (len == 0) - calculated_image_path remains None (no match)
                    else:
                        print(f"Debug: Thumbnail folder not found: {thumbnail_folder}")

                # Add the calculated image_path to the version dictionary
                v['image_path'] = calculated_image_path
                # --- END NEW LOGIC ---

                if tab_context:
                    try:
                        # Split context into main type (e.g., "rig") and sub-category (e.g., "vehicles")
                        type_part, category_part = tab_context.split('/')
                        
                        # print(f"\nDebug - Checking version: {v.get('code')}")
                        # print(f"Type match: {v.get('category')} == {type_part}? {v.get('category') == type_part}")
                        
                        # Get abbreviation for category (e.g., 'characters' -> 'chr')
                        abbreviation = CATEGORY_ABBREVIATIONS.get(category_part, '')
                        code_lower = v.get('code', '').lower()
                        # print(f"Looking for abbreviation: '{abbreviation}' in '{code_lower}'")
                        
                        # Apply filtering logic based on category and abbreviation in code
                        if (v.get('category', '') == type_part and 
                            abbreviation and abbreviation in code_lower):
                            filtered_versions.append(v)
                            # print("-> MATCH")
                        # else:
                            # print("-> NO MATCH (filter criteria not met)")
                    except ValueError:
                        # print(f"Debug: tab_context '{tab_context}' has no '/' for splitting. Treating as single-part filter.")
                        # If it's a single part (e.g., "anim"), filter by main category only
                        if v.get('category', '') == tab_context:
                            filtered_versions.append(v)
                            # print("-> MATCH (single-part category)")
                        # else:
                            # print("-> NO MATCH (single-part category)")
                    except Exception as e:
                        print(f"Filter error in context parsing for version {v.get('code')}: {str(e)}")
                        filtered_versions.append(v) # If context parsing fails for a version, include it
                else: # If no tab_context, or it couldn't be parsed, include all versions.
                    filtered_versions.append(v)
                    
            print(f"\nFiltered {len(filtered_versions)}/{len(versions)} versions for context: {tab_context}")
                    
            for v in filtered_versions:
                print("{:<15} | {:<80} | {:<30}".format(
                    v.get('code', 'N/A')[:15],
                    str(v.get('sg_path_to_geometry', 'N/A')),
                    str(v.get('image_path', 'N/A') if v.get('image_path') else v.get('image', 'N/A'))[:30] # Print calculated path, else original prefix
                ))
            
            current_main_tab_widget = self.bottom_tab_widget.currentWidget()

            if current_main_tab_widget:
                if isinstance(current_main_tab_widget, QtWidgets.QTabWidget):
                    active_content_container = current_main_tab_widget.currentWidget()
                else:
                    active_content_container = current_main_tab_widget

                if active_content_container:
                    self._setup_simple_scroll_content(active_content_container, filtered_versions)

        except Exception as e:
            print(f"Refresh failed: {str(e)}")
            import traceback
            traceback.print_exc()
            
    def _create_thumbnail_widget(self, version_data):
        """Create a thumbnail widget for a version"""
        widget = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(widget)
        layout.setContentsMargins(5, 5, 5, 5) 
        layout.setSpacing(2)

        thumb_label = QtWidgets.QLabel()
        thumb_label.setFixedSize(120, 90)
        thumb_label.setStyleSheet("background-color: #333; border: 1px solid #555;")
        thumb_label.setAlignment(QtCore.Qt.AlignCenter)
        
        # Use 'image_path' which is now populated by _handle_refresh
        image_path = version_data.get('image_path') 
        if image_path and os.path.exists(image_path):
            pixmap = QtGui.QPixmap(image_path)
            if not pixmap.isNull():
                thumb_label.setPixmap(pixmap.scaled(thumb_label.size(), 
                                                     QtCore.Qt.KeepAspectRatio, 
                                                     QtCore.Qt.SmoothTransformation))
            else:
                thumb_label.setText("No Image") # Pixmap was null
        else:
            thumb_label.setText("No Image") # Path not found or not provided

        name_label = QtWidgets.QLabel(version_data.get('code', 'N/A'))
        name_label.setAlignment(QtCore.Qt.AlignCenter)
        name_label.setWordWrap(True) 
        name_label.setToolTip(version_data.get('code', 'N/A'))
        
        layout.addWidget(thumb_label)
        layout.addWidget(name_label)
        return widget
        
    def _update_bottom_tabs(self, index):
        """
        Updates the tabs in the bottom QTabWidget based on the top tab selection.
        Args:
            index (int): 0 for Assets, 1 for Shots (corresponds to top_tab_bar index)
        """
        current_bottom_tab_index = self.bottom_tab_widget.currentIndex()

        for i in range(self.bottom_tab_widget.count() - 1, -1, -1):
            widget_to_remove = self.bottom_tab_widget.widget(i)
            self.bottom_tab_widget.removeTab(i)

        # Assets Top
        if index == 0: 
            types_to_display = self.ASSET_TYPES

            for tab_name in types_to_display:
                if tab_name not in self.dynamic_tab_content_cache:
                    new_content_widget = self._create_main_tab_content_widget(tab_name)
                    self.dynamic_tab_content_cache[tab_name] = new_content_widget
                
                self.bottom_tab_widget.addTab(self.dynamic_tab_content_cache[tab_name], tab_name)

            # if current_bottom_tab_index < self.bottom_tab_widget.count():
            #     self.bottom_tab_widget.setCurrentIndex(current_bottom_tab_index)
            # else:
            #     self.bottom_tab_widget.setCurrentIndex(0)
        # Shots Top               
        else:
            self._create_shot_structure_tabs()


    def _create_shot_structure_tabs(self):
        seq_codes, shots_codes_nested = self._analyze_shotgun_data_from_env()

        shot_types_main_tab_widget = QtWidgets.QTabWidget()


        for shot_type_name in self.SHOT_TYPES:
            sequences_for_shot_type_tab_widget = QtWidgets.QTabWidget()
            self.bottom_tab_widget.addTab(sequences_for_shot_type_tab_widget, shot_type_name)

            if not seq_codes: 
                no_seq_label = QtWidgets.QLabel("No sequences found from environment variables.")
                no_seq_label.setAlignment(QtCore.Qt.AlignCenter)
                no_seq_widget = QtWidgets.QWidget()
                no_seq_layout = QtWidgets.QVBoxLayout(no_seq_widget)
                no_seq_layout.addWidget(no_seq_label)
                sequences_for_shot_type_tab_widget.addTab(no_seq_widget, "No Sequences")
                continue

            for seq_idx, seq_code in enumerate(seq_codes):
                shots_in_seq_tab_widget = QtWidgets.QTabWidget()
                sequences_for_shot_type_tab_widget.addTab(shots_in_seq_tab_widget, seq_code)

                shots_for_this_seq = shots_codes_nested[seq_idx]
                if not shots_for_this_seq:
                    no_shots_label = QtWidgets.QLabel(f"No shots found for sequence: {seq_code}")
                    no_shots_label.setAlignment(QtCore.Qt.AlignCenter)
                    no_shots_widget = QtWidgets.QWidget()
                    no_shots_layout = QtWidgets.QVBoxLayout(no_shots_widget)
                    no_shots_layout.addWidget(no_shots_label)
                    shots_in_seq_tab_widget.addTab(no_shots_widget, "No Shots")
                    continue

                for shot_code in sorted(shots_for_this_seq):
                    shot_content_widget = QtWidgets.QWidget()
                    self._setup_simple_scroll_content(shot_content_widget, [])
                    shots_in_seq_tab_widget.addTab(shot_content_widget, shot_code)
            
    def _create_main_tab_content_widget(self, tab_name):
        """
        Creates and returns the appropriate content widget for tabs added directly to `bottom_tab_widget`.
        This handles the nesting for Asset Types.
        """
        if tab_name in self.ASSET_TYPES:
            inner_tab_widget = QtWidgets.QTabWidget()
            
            for category_name in self.HAL_CATEGORY_TYPES:
                category_content_widget = QtWidgets.QWidget()
                self._setup_simple_scroll_content(category_content_widget, []) 
                inner_tab_widget.addTab(category_content_widget, category_name)
            
            return inner_tab_widget
            
        elif tab_name in self.SHOT_TYPES:
            shot_type_content_widget = QtWidgets.QWidget()
            self._setup_simple_scroll_content(shot_type_content_widget, []) 
            return shot_type_content_widget
        
        return QtWidgets.QWidget() 

    def _setup_simple_scroll_content(self, parent_widget, versions_data=None):
        """
        Sets up a basic scrollable area and populates it with thumbnail widgets.
        Args:
            parent_widget (QtWidgets.QWidget): The widget to set up the scroll area in.
            versions_data (list): A list of version dictionaries to display.
        """
        if versions_data is None:
            versions_data = []

        existing_scroll = parent_widget.findChild(QtWidgets.QScrollArea)
        if existing_scroll:
            existing_scroll.deleteLater()
            if parent_widget.layout():
                parent_widget.layout().removeWidget(existing_scroll)
        
        main_layout = parent_widget.layout()
        if not main_layout:
            main_layout = QtWidgets.QVBoxLayout(parent_widget)
            parent_widget.setLayout(main_layout)
        
        main_layout.setContentsMargins(0,0,0,0) 
        main_layout.setSpacing(0) 

        scroll = QtWidgets.QScrollArea()
        scroll.setWidgetResizable(True)
        
        container = QtWidgets.QWidget()
        content_layout = QtWidgets.QGridLayout(container) 
        content_layout.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft) 
        content_layout.setContentsMargins(10, 10, 10, 10) 
        content_layout.setSpacing(10) 
        
        container.setLayout(content_layout)
        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        column_count = 5 
        row = 0
        col = 0
        if versions_data:
            for version in versions_data:
                thumb_widget = self._create_thumbnail_widget(version)
                content_layout.addWidget(thumb_widget, row, col)
                col += 1
                if col >= column_count:
                    col = 0
                    row += 1
            content_layout.addItem(QtWidgets.QSpacerItem(0, 0, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding), row + 1, 0, 1, column_count)
        else:
            no_data_label = QtWidgets.QLabel("No items found for this category. Click 'Refresh' to load data.") 
            no_data_label.setAlignment(QtCore.Qt.AlignCenter)
            content_layout.addWidget(no_data_label, 0, 0, 1, column_count)
            content_layout.addItem(QtWidgets.QSpacerItem(0, 0, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding), 1, 0, 1, column_count)
        
    def setup_options_panel(self, parent_widget): 
        """Setup content for the 'Options' widget (now a standalone panel)."""
        layout = QtWidgets.QVBoxLayout(parent_widget)
        
        title_label = QtWidgets.QLabel("Options")
        title_label.setAlignment(QtCore.Qt.AlignCenter)
        title_label.setStyleSheet("font-weight: bold; font-size: 14px; padding-bottom: 5px;")
        layout.addWidget(title_label)

        render_group = QtWidgets.QGroupBox("View Settings")
        render_layout = QtWidgets.QGridLayout()
        
        render_label = QtWidgets.QLabel("View Mode:")
        self.render_combo = QtWidgets.QComboBox()
        self.render_combo.addItems(["List View", "Thumbnail View"])
        
        material_label = QtWidgets.QLabel("Filter By:")
        self.material_combo = QtWidgets.QComboBox()
        
        render_layout.addWidget(render_label, 0, 0)
        render_layout.addWidget(self.render_combo, 0, 1)
        render_layout.addWidget(material_label, 1, 0)
        render_layout.addWidget(self.material_combo, 1, 1)
        render_group.setLayout(render_layout)
        
        layout.addWidget(render_group)
        layout.addStretch()

    def _analyze_shotgun_data_from_env(self):
        """
        Analyzes sequence and shot data from environment variables `SG_Find_Sequence` and `SG_Find_Shot`.
        Parses the data, groups shots by sequence, and returns sorted lists of sequences and shots.
        Returns:
            tuple: (sorted_sequence_codes, shots_codes_nested)
                   - sorted_sequence_codes (list): A list of sequence codes, sorted alphabetically.
                   - shots_codes_nested (list of lists): A list where each inner list contains
                                                         the sorted shot codes belonging to the
                                                         corresponding sequence in `sorted_sequence_codes`.
                                                         An empty list if a sequence has no shots.
        """
        sequences_str = os.environ.get("SG_Find_Sequence")
        shots_str = os.environ.get("SG_Find_Shot")

        if not sequences_str and not shots_str:
            print("Error: Environment variables SG_Find_Sequence and SG_Find_Shot are not set. Cannot perform analysis.")
            return [], []

        all_sequences = []
        all_shots = []

        if sequences_str:
            try:
                all_sequences = ast.literal_eval(sequences_str)
            except (ValueError, SyntaxError) as e:
                print(f"Error parsing SG_Find_Sequence: {e}")
                print(f"Partial content: {sequences_str[:200]}...")
                return [], []

        if shots_str:
            try:
                all_shots = ast.literal_eval(shots_str)
            except (ValueError, SyntaxError) as e:
                print(f"Error parsing SG_Find_Shot: {e}")
                print(f"Partial content: {shots_str[:200]}...")
                return [], []

        sequence_to_shots = {}

        # Initialize sequence_to_shots with all known sequences
        for seq_data in all_sequences:
            seq_code = seq_data.get('code')
            if seq_code:
                sequence_to_shots[seq_code] = []

        # Populate sequence_to_shots with shots
        for shot in all_shots:
            shot_code = shot.get('code')
            sequence_info = shot.get('sequence')
            seq_code_for_shot = None

            if sequence_info and sequence_info.get('code'):
                seq_code_for_shot = sequence_info['code']

            if shot_code:
                if seq_code_for_shot:
                    # If sequence is not yet in our map (e.g., from a shot, but not in SG_Find_Sequence explicitly)
                    if seq_code_for_shot not in sequence_to_shots:
                        sequence_to_shots[seq_code_for_shot] = []
                    sequence_to_shots[seq_code_for_shot].append(shot_code)
                else:
                    # Handle shots not assigned to any specific sequence
                    unassigned_key = "未分配序列"
                    if unassigned_key not in sequence_to_shots:
                        sequence_to_shots[unassigned_key] = []
                    sequence_to_shots[unassigned_key].append(shot_code)

        # Prepare return values: sorted sequences and corresponding sorted shots
        sorted_sequence_codes = sorted(sequence_to_shots.keys())
        shots_codes_nested = []

        for seq_code in sorted_sequence_codes:
            # Ensure shots within each sequence are also sorted
            shots_codes_nested.append(sorted(sequence_to_shots[seq_code]))

        return sorted_sequence_codes, shots_codes_nested