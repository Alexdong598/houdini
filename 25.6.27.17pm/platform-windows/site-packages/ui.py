import importlib
import sys
from PySide2 import QtWidgets, QtCore, QtGui
import os 
import ast
import json

class CustomThumbnailWidget(QtWidgets.QFrame):
    clicked = QtCore.Signal(int, QtWidgets.QWidget)
    
    def __init__(self, version_data, parent=None):
        super(CustomThumbnailWidget, self).__init__(parent)
        self.version_data = version_data
        self.is_selected = False
        self.mouse_press_pos = None
        
        self.setFrameShape(QtWidgets.QFrame.Box)
        self.setFrameShadow(QtWidgets.QFrame.Raised)
        self.setLineWidth(1)
        self.setCursor(QtCore.Qt.PointingHandCursor)
        self.setAcceptDrops(False)

        self._setup_ui()
        self.set_selected(False)

    def _setup_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5) 
        layout.setSpacing(2)

        thumb_label = QtWidgets.QLabel()
        thumb_label.setFixedSize(120, 90)
        thumb_label.setStyleSheet("background-color: #333;")
        thumb_label.setAlignment(QtCore.Qt.AlignCenter)
        
        image_path = self.version_data.get('image_path') 
        if image_path and os.path.exists(image_path):
            pixmap = QtGui.QPixmap(image_path)
            if not pixmap.isNull():
                thumb_label.setPixmap(pixmap.scaled(thumb_label.size(), 
                                                     QtCore.Qt.KeepAspectRatio, 
                                                     QtCore.Qt.SmoothTransformation))
            else:
                thumb_label.setText("No Image")
        else:
            thumb_label.setText("No Image")

        name_label = QtWidgets.QLabel(self.version_data.get('code', 'N/A'))
        name_label.setAlignment(QtCore.Qt.AlignCenter)
        name_label.setWordWrap(True) 
        name_label.setToolTip(self.version_data.get('code', 'N/A'))
        
        layout.addWidget(thumb_label)
        layout.addWidget(name_label)
        
    def set_selected(self, selected: bool):
        self.is_selected = selected
        if selected:
            self.setStyleSheet("QFrame { border: 2px solid #4CAF50; background-color: #3a3a3a; }")
        else:
            self.setStyleSheet("QFrame { border: 1px solid #555; background-color: #2a2a2a; }")

    def mousePressEvent(self, event: QtGui.QMouseEvent):
        if event.button() == QtCore.Qt.LeftButton:
            self.mouse_press_pos = event.pos()
            self.set_selected(not self.is_selected)
            self.clicked.emit(self.version_data.get('id'), self)
        super(CustomThumbnailWidget, self).mousePressEvent(event)

    def mouseMoveEvent(self, event: QtGui.QMouseEvent):
        if event.buttons() & QtCore.Qt.LeftButton and self.mouse_press_pos:
            drag_threshold = QtWidgets.QApplication.startDragDistance()
            if (event.pos() - self.mouse_press_pos).manhattanLength() >= drag_threshold:
                if self.is_selected:
                    self._start_drag()
                self.mouse_press_pos = None
        super(CustomThumbnailWidget, self).mouseMoveEvent(event)

    def _start_drag(self):
        drag = QtGui.QDrag(self)
        mime_data = QtCore.QMimeData()
        
        # --- 修改这里：从 'selected_geo_path' 获取实际要拖拽的单个文件路径 ---
        file_path = self.version_data.get('selected_geo_path')
        
        if file_path:
            uri_list = [QtCore.QUrl.fromLocalFile(file_path).toEncoded().data().decode()]
            mime_data.setData("text/uri-list", "\n".join(uri_list).encode())
            drag.setMimeData(mime_data)
            drop_action = drag.exec_(QtCore.Qt.CopyAction | QtCore.Qt.MoveAction)
            
            if drop_action == QtCore.Qt.CopyAction:
                print(f"File '{file_path}' dragged successfully (Copy).")
            elif drop_action == QtCore.Qt.MoveAction:
                print(f"File '{file_path}' dragged successfully (Move).")
            else:
                print(f"Drag operation for '{file_path}' cancelled or failed.")
        else:
            print(f"No geometry path to drag for {self.version_data.get('code')}.")

# 定义需要重新加载的依赖模块
# 这里我们假设 shotgun_data_manager 是唯一的外部依赖
DEPENDENT_MODULE_NAMES = [
    "shotgun_data_manager", 
]

def get_command():
    def _command():
        try:
            window = ShotgunLibraryUI()
            window.show()
        except Exception as e:
            print(f"Failed to create ShotgunLibraryUI: {str(e)}")
            import traceback
            traceback.print_exc()
    return _command

_window_instance = None

def execute():
    """
    Initializes or re-initializes the ShotgunLibraryUI.
    This function handles hot-reloading of the UI module and its dependencies.
    """
    global _window_instance
    
    # --- 1. 重新加载依赖模块 ---
    for module_name in DEPENDENT_MODULE_NAMES:
        if module_name in sys.modules:
            try:
                importlib.reload(sys.modules[module_name])
                print(f"Successfully reloaded dependent module: {module_name}")
            except Exception as e:
                print(f"Failed to reload dependent module '{module_name}': {e}")
                raise # 如果依赖模块无法重新加载，通常意味着更严重的问题，直接抛出

    # --- 2. 重新加载当前 UI 模块 ---
    try:
        importlib.reload(sys.modules[__name__])
        print(f"Successfully reloaded current UI module: {__name__}")
    except Exception as e:
        print(f"Failed to reload current UI module '{__name__}': {e}")
        raise # 当前模块无法重新加载，必须抛出错误

    # --- 3. 清理并关闭旧的 UI 实例 ---
    if _window_instance:
        try:
            # 确保在关闭前断开所有信号连接，避免旧的槽函数被触发
            _window_instance.close()
            # 标记为删除，帮助 PySide/Qt 清理内存
            _window_instance.deleteLater() 
            _window_instance = None 
            print("Closed and cleared old window instance.")
        except Exception as e:
            print(f"Warning: Could not gracefully close previous window instance: {e}")
            import traceback
            traceback.print_exc()
            pass # 忽略错误，继续尝试创建新实例
    
    # --- 4. 创建新的 UI 实例 ---
    try:
        # 确保从重新加载后的模块中获取 ShotgunLibraryUI 类
        _window_instance = sys.modules[__name__].ShotgunLibraryUI()
        # WA_DeleteOnClose 设置为 False，因为我们手动管理实例生命周期
        _window_instance.setAttribute(QtCore.Qt.WA_DeleteOnClose, False) 
        _window_instance.show()
        print("Successfully created new UI instance.")
        return _window_instance
    except Exception as e:
        print(f"Failed to create new window: {str(e)}")
        import traceback
        traceback.print_exc()
        raise

class ShotgunLibraryUI(QtWidgets.QWidget):
    """Main UI window for Shotgun Library."""
    
    ASSET_TYPES = ["mdl", "shd", "rig", "txt", "cgfx-setup", "cncpt"]
    SHOT_TYPES = ["anim", "cgfx", "comp", "layout", "lgt", "mm", "matp", "paint", "roto"]
    
    HAL_CATEGORY_TYPES = ["cgfx", "characters", "environments", "props", "vehicles"]
    
    def __init__(self):
        super(ShotgunLibraryUI, self).__init__()
        self.setWindowTitle("Shotgun Library")
        self.resize(1200, 600)
        self.current_selected_format = ""
        self.selected_thumbnail_widgets = {}
        self.selected_version_ids = set()
        
        try:
            # 从重新加载的模块中获取 ShotgunDataManager 类
            from shotgun_data_manager import ShotgunDataManager
            self.data_manager = ShotgunDataManager()
        except (ImportError, Exception) as e: # 捕获更广泛的错误
            print(f"Error: Could not import or initialize ShotgunDataManager: {e}")
            print("Falling back to DummyDataManager.")
            class DummyDataManager:
                def find_files(self, tab_context=""):
                    print("DummyDataManager: Returning dummy data.")
                    # 模拟新的 sg_path_to_geometry 列表格式
                    return [
                        {"id": 1, "code": "mdl_char_hero_v001", "sg_path_to_geometry": ["X:/project/assets/characters/hero/mdl/hero_v001.mb", "X:/project/assets/characters/hero/mdl/hero_v001.usd"], "image": "thumb_hero", "entity": {"type": "Asset", "id": 101, "name": "char_hero"}, "category": "mdl", "sg_category": "characters"},
                        {"id": 2, "code": "rig_prop_lamp_v002", "sg_path_to_geometry": ["X:/project/assets/props/lamp/rig/lamp_v002.mb", "X:/project/assets/props/lamp/rig/lamp_v002.abc"], "image": "thumb_lamp", "entity": {"type": "Asset", "id": 102, "name": "prop_lamp"}, "category": "rig", "sg_category": "props"},
                        {"id": 3, "code": "anim_shot010_v001", "sg_path_to_geometry": ["X:/project/shots/shot010/anim/shot010_v001.ma", "X:/project/shots/shot010/anim/shot010_v001.usdc"], "image": "thumb_shot", "entity": {"type": "Shot", "id": 201, "name": "shot010"}, "category": "anim"},
                        # This entry is specifically for the 'rig/vehicles' test case
                        {"id": 4, "code": "rig_veh_benz_v085", "sg_path_to_geometry": ["X:/pipelinernd_rnd-0192/_library/assets/vehicles/veh_benz/rig/_publish/rnd_veh_benz_rig_v085_yud.usdc", "X:/pipelinernd_rnd-0192/_library/assets/vehicles/veh_benz/rig/_publish/rnd_veh_benz_rig_v085_yud.abc", "X:/pipelinernd_rnd-0192/_library/assets/vehicles/veh_benz/rig/_publish/rnd_veh_benz_rig_v085_yud.bgeo.sc"], "image": "rnd_veh_benz_rig_v085_yud_temp", "entity": {"type": "Asset", "id": 103, "name": "veh_benz"}, "category": "rig", "sg_category": "vehicles"}
                    ]
            self.data_manager = DummyDataManager()
        
        self.dynamic_tab_content_cache = {} 
        self.current_selected_format = "" # 用于存储当前选中的格式筛选器
        
        self.setup_ui()
        # 确保在UI初始化后，立即根据当前选中的顶部标签更新底部标签和内容
        self._update_bottom_tabs(self.top_tab_bar.currentIndex()) 
        # self._update_bottom_tabs(self.top_tab_bar.currentIndex()) # 这一行可以删除，或保持注释，上面一行是生效的
        
    def setup_ui(self):
        """Create and arrange UI components."""
        self.main_h_layout = QtWidgets.QHBoxLayout(self) 
        
        self.left_panel_v_layout = QtWidgets.QVBoxLayout() 
        
        self.top_tab_bar = QtWidgets.QTabBar()
        self.top_tab_bar.addTab("Assets")
        self.top_tab_bar.addTab("Shots")
        self.top_tab_bar.currentChanged.connect(self._update_bottom_tabs)
        
        self.bottom_tab_widget = QtWidgets.QTabWidget()
        
        controls_layout = QtWidgets.QHBoxLayout()
        self.refresh_btn = QtWidgets.QPushButton("Refresh")
        self.close_btn = QtWidgets.QPushButton("Close")
        
        controls_layout.addWidget(self.refresh_btn)
        controls_layout.addStretch() 
        controls_layout.addWidget(self.close_btn)
        
        self.left_panel_v_layout.addWidget(self.top_tab_bar)
        self.left_panel_v_layout.addWidget(self.bottom_tab_widget)
        self.left_panel_v_layout.addLayout(controls_layout)
        
        self.options_widget = QtWidgets.QWidget() 
        self.setup_options_panel(self.options_widget) 
        
        self.main_h_layout.addLayout(self.left_panel_v_layout, 2) 
        self.main_h_layout.addWidget(self.options_widget, 1) 
        
        self.close_btn.clicked.connect(self.close)
        self.refresh_btn.clicked.connect(self._handle_refresh)

        # 连接格式筛选下拉框的信号
        self.render_combo.currentIndexChanged.connect(self._handle_format_selection_change)
            
    def _get_file_format(self, file_path: str) -> str:
        """
        Extracts the file format from a given path, handling special cases like .bgeo.sc.
        Example:
            "path/to/file.usdc" -> "usdc"
            "path/to/file.bgeo.sc" -> "bgeo"
            "path/to/file.abc" -> "abc"
        """
        if not file_path or not isinstance(file_path, str):
            return "unknown"
        
        parts = file_path.split('.')
        if len(parts) < 2: # No extension
            return "unknown"
        
        last_ext = parts[-1].lower()
        if last_ext == "sc" and len(parts) >= 3:
            second_last_ext = parts[-2].lower()
            if second_last_ext == "bgeo":
                return "bgeo" # Special case for .bgeo.sc
        
        return last_ext

    def _handle_format_selection_change(self, index):
        """
        Handles the change in the format selection combo box.
        Triggers a refresh to update displayed items based on the new format.
        """
        self.current_selected_format = self.render_combo.currentText()
        print(f"Format filter changed to: {self.current_selected_format}")
        self._handle_refresh() # 重新触发刷新以应用新的格式筛选

    def _handle_refresh(self):
            """
            Handle refresh button click - fetch and display Shotgun data.
            (Updated version with simplified logic and stable thumbnail loading)
            """
            try:
                # 1. 清理当前选中状态
                self.selected_version_ids.clear()
                self.selected_thumbnail_widgets.clear()
                
                # 2. 获取当前UI的上下文
                current_tab = self.bottom_tab_widget.currentWidget()
                tab_context = ""
                if current_tab:
                    tab_index = self.bottom_tab_widget.currentIndex()
                    tab_name = self.bottom_tab_widget.tabText(tab_index)
                    
                    if isinstance(current_tab, QtWidgets.QTabWidget):
                        inner_tab = current_tab.currentWidget()
                        inner_index = current_tab.currentIndex()
                        inner_name = current_tab.tabText(inner_index)
                        tab_context = f"{tab_name}/{inner_name}"
                    else:
                        tab_context = tab_name
                
                print(f"\nCurrent context: {tab_context}")
                versions = self.data_manager.find_files(tab_context) 
                
                # 3. 健壮性处理：确保 'sg_path_to_geometry' 总是列表格式
                processed_versions = []
                for version in versions:
                    geometry_paths = version.get('sg_path_to_geometry')
                    
                    if isinstance(geometry_paths, str):
                        try:
                            evaluated_path = ast.literal_eval(geometry_paths)
                            version['sg_path_to_geometry'] = evaluated_path if isinstance(evaluated_path, list) else [geometry_paths]
                        except (ValueError, SyntaxError):
                            version['sg_path_to_geometry'] = [geometry_paths]
                    elif geometry_paths is None:
                        version['sg_path_to_geometry'] = []
                    elif not isinstance(geometry_paths, list):
                        version['sg_path_to_geometry'] = [geometry_paths]
                    
                    processed_versions.append(version)
                versions = processed_versions

                # --- START: 简化后的核心逻辑 ---

                # 4. 从数据中收集所有可用的文件格式
                unique_formats = set()
                for v in versions:
                    for path in v.get('sg_path_to_geometry', []):
                        format = self._get_file_format(path)
                        if format != "unknown":
                            unique_formats.add(format)
                sorted_formats = sorted(list(unique_formats))

                # 5. 决定本次刷新要使用的格式筛选器
                #    优先使用UI上已有的选择，如果选择无效（比如切换了上下文），则使用默认的第一个
                selected_format_filter = ""
                current_ui_selection = self.render_combo.currentText()
                if current_ui_selection in sorted_formats:
                    selected_format_filter = current_ui_selection
                elif sorted_formats:
                    selected_format_filter = sorted_formats[0]
                
                # 6. 更新UI下拉框以反映我们的决定，并同步内部状态变量
                self.render_combo.blockSignals(True)
                self.render_combo.clear()
                if sorted_formats:
                    self.render_combo.addItems(sorted_formats)
                    self.render_combo.setCurrentText(selected_format_filter)
                else:
                    self.render_combo.addItem("No formats available")
                self.render_combo.blockSignals(False)
                self.current_selected_format = selected_format_filter # 在所有决定后，一次性更新状态

                # 7. 在一个循环内，完成所有数据处理和路径选择
                final_versions_for_display = []
                for v in versions:
                    original_paths = v.get('sg_path_to_geometry', [])
                    
                    # 7a. 确定用于【拖拽】的路径 (selected_geo_path)，这个路径依赖于格式筛选
                    selected_geo_path = None
                    if original_paths:
                        found_match = False
                        if selected_format_filter:
                            for path in original_paths:
                                if self._get_file_format(path) == selected_format_filter:
                                    selected_geo_path = path
                                    found_match = True
                                    break
                        if not found_match:
                            selected_geo_path = original_paths[0] # Fallback to the first path
                    v['selected_geo_path'] = selected_geo_path

                    # 7b. 确定用于【显示缩略图】的路径 (image_path)，这个路径不依赖筛选，永远保持稳定
                    calculated_image_path = None
                    if original_paths:
                        # **关键修复**：我们总是使用原始列表的第一个路径来查找缩略图
                        path_for_thumbnail_lookup = original_paths[0]
                        image_prefix = v.get('image')

                        if path_for_thumbnail_lookup and image_prefix:
                            dirname = os.path.dirname(path_for_thumbnail_lookup)
                            thumbnail_folder = os.path.join(dirname, "_SGthumbnail")

                            if os.path.isdir(thumbnail_folder):
                                matching_files = []
                                try:
                                    for filename in os.listdir(thumbnail_folder):
                                        if isinstance(filename, str) and filename.startswith(image_prefix):
                                            matching_files.append(filename)
                                except OSError as e:
                                    print(f"Warning: Could not list directory {thumbnail_folder} due to {e}")
                                
                                if len(matching_files) == 1:
                                    calculated_image_path = os.path.join(thumbnail_folder, matching_files[0])
                                elif len(matching_files) > 1:
                                    print(f"Warning: Multiple image files for prefix '{image_prefix}'. No thumbnail.")

                    v['image_path'] = calculated_image_path.replace(os.sep, "/") if calculated_image_path else None
                    
                    final_versions_for_display.append(v)

                # --- END: 简化后的核心逻辑 ---

                # 8. 打印日志，确认最终处理结果
                print("\n--- Final Processed Data ---")
                print("{:<20} | {:<70} | {:<70}".format("Version Code", "Draggable Path (selected)", "Thumbnail Path (calculated)"))
                print("-" * 165)
                for v in final_versions_for_display:
                    print("{:<20} | {:<70} | {:<70}".format(
                        v.get('code', 'N/A')[:20],
                        str(v.get('selected_geo_path', 'N/A')),
                        str(v.get('image_path', 'N/A'))
                    ))
                print("-" * 165)

                # 9. 将最终处理好的数据送去更新UI
                current_main_tab_widget = self.bottom_tab_widget.currentWidget()
                if current_main_tab_widget:
                    active_content_container = current_main_tab_widget
                    if isinstance(current_main_tab_widget, QtWidgets.QTabWidget):
                        active_content_container = current_main_tab_widget.currentWidget()

                    if active_content_container:
                        self._setup_simple_scroll_content(active_content_container, final_versions_for_display)
                    else:
                        print("No active content container to display versions.")

            except Exception as e:
                print(f"Refresh failed: {str(e)}")
                import traceback
                traceback.print_exc()
            
    def _create_thumbnail_widget(self, version_data):
        """Create a CustomThumbnailWidget for a version"""
        thumb_widget = CustomThumbnailWidget(version_data, parent=self)
        thumb_widget.clicked.connect(self._handle_thumbnail_click)
        
        if version_data.get('id') in self.selected_version_ids:
            thumb_widget.set_selected(True)
            self.selected_thumbnail_widgets[version_data.get('id')] = thumb_widget
        else:
            thumb_widget.set_selected(False)

        return thumb_widget

    def _handle_thumbnail_click(self, version_id: int, widget: CustomThumbnailWidget):
        """
        处理缩略图的点击事件，实现单选功能。
        当点击一个缩略图时：
        - 如果它被选中（即点击后变为选中状态），则将其设为唯一选中项，并取消其他所有项的选中。
        - 如果它被取消选中（即点击后变为未选中状态），则将其从选中列表中移除。
        """
        # 获取当前点击的 widget 的新选中状态 (CustomThumbnailWidget 已经在 mousePressEvent 中更新了自身状态)
        is_currently_selected = widget.is_selected

        if is_currently_selected: # 如果点击后该widget变为选中状态 (之前未选中，现在被选中了)
            # 先清空所有旧的选中项
            # 注意：这里需要迭代 selected_thumbnail_widgets 的副本，因为我们会在循环中修改它
            for old_id, old_widget in list(self.selected_thumbnail_widgets.items()):
                if old_id != version_id: # 如果不是当前点击的这个widget
                    old_widget.set_selected(False) # 取消其选中状态
            
            # 清空所有选中记录，准备只记录当前点击的这个
            self.selected_thumbnail_widgets.clear()
            self.selected_version_ids.clear()

            # 然后将当前点击的这个设为唯一选中项
            self.selected_thumbnail_widgets[version_id] = widget
            self.selected_version_ids.add(version_id)
        else: # 如果点击后该widget变为未选中状态 (之前已选中，现在被点击取消了)
            self.selected_thumbnail_widgets.pop(version_id, None) # 从字典中移除
            self.selected_version_ids.discard(version_id) # 从集合中移除
        
        print(f"Selected versions ({len(self.selected_version_ids)}): {list(self.selected_version_ids)}")
        
    def _update_bottom_tabs(self, index):
        """
        Updates the tabs in the bottom QTabWidget based on the top tab selection.
        Args:
            index (int): 0 for Assets, 1 for Shots (corresponds to top_tab_bar index)
        """
        # Save current bottom tab index if needed for later restoration (optional)
        # current_bottom_tab_index = self.bottom_tab_widget.currentIndex()

        # Clear all existing tabs from bottom_tab_widget
        for i in range(self.bottom_tab_widget.count() - 1, -1, -1):
            widget_to_remove = self.bottom_tab_widget.widget(i)
            self.bottom_tab_widget.removeTab(i)
            # widget_to_remove.deleteLater() # Optional: help with memory management

        # Assets Top
        if index == 0: 
            types_to_display = self.ASSET_TYPES

            for tab_name in types_to_display:
                if tab_name not in self.dynamic_tab_content_cache:
                    new_content_widget = self._create_main_tab_content_widget(tab_name)
                    self.dynamic_tab_content_cache[tab_name] = new_content_widget
                
                self.bottom_tab_widget.addTab(self.dynamic_tab_content_cache[tab_name], tab_name)

            # Restore or set initial current index (optional)
            # if current_bottom_tab_index < self.bottom_tab_widget.count():
            #     self.bottom_tab_widget.setCurrentIndex(current_bottom_tab_index)
            # else:
            #     self.bottom_tab_widget.setCurrentIndex(0)
        # Shots Top               
        else:
            self._create_shot_structure_tabs()
        
        # 每次切换顶层标签后，自动刷新以显示内容
        # self._handle_refresh()

    def _show_refresh_prompt_in_active_tab(self):
        """
        在当前激活的内容区域显示“点击刷新”提示。
        """
        current_main_tab_widget = self.bottom_tab_widget.currentWidget()
        if current_main_tab_widget:
            if isinstance(current_main_tab_widget, QtWidgets.QTabWidget):
                active_content_container = current_main_tab_widget.currentWidget()
            else:
                active_content_container = current_main_tab_widget

            if active_content_container:
                # 重新设置内容，但传入空数据，以显示“无数据”或“点击刷新”提示
                self._setup_simple_scroll_content(active_content_container, [])

    def _create_shot_structure_tabs(self):
        seq_codes, shots_codes_nested = self._analyze_shotgun_data_from_env()

        # 这个 shot_types_main_tab_widget 似乎没有被添加到任何布局中，可能是一个逻辑错误
        # shot_types_main_tab_widget = QtWidgets.QTabWidget() 

        for shot_type_name in self.SHOT_TYPES:
            sequences_for_shot_type_tab_widget = QtWidgets.QTabWidget()
            # 这里将 shot_type_name 对应的 QTabWidget 添加到 bottom_tab_widget
            self.bottom_tab_widget.addTab(sequences_for_shot_type_tab_widget, shot_type_name)

            if not seq_codes: 
                no_seq_label = QtWidgets.QLabel("No sequences found from environment variables.")
                no_seq_label.setAlignment(QtCore.Qt.AlignCenter)
                no_seq_widget = QtWidgets.QWidget()
                no_seq_layout = QtWidgets.QVBoxLayout(no_seq_widget)
                no_seq_layout.addWidget(no_seq_label)
                sequences_for_shot_type_tab_widget.addTab(no_seq_widget, "No Sequences")
                continue

            for seq_idx, seq_code in enumerate(seq_codes):
                shots_in_seq_tab_widget = QtWidgets.QTabWidget()
                sequences_for_shot_type_tab_widget.addTab(shots_in_seq_tab_widget, seq_code)

                shots_for_this_seq = shots_codes_nested[seq_idx]
                if not shots_for_this_seq:
                    no_shots_label = QtWidgets.QLabel(f"No shots found for sequence: {seq_code}")
                    no_shots_label.setAlignment(QtCore.Qt.AlignCenter)
                    no_shots_widget = QtWidgets.QWidget()
                    no_shots_layout = QtWidgets.QVBoxLayout(no_shots_widget)
                    no_shots_layout.addWidget(no_shots_label)
                    shots_in_seq_tab_widget.addTab(no_shots_widget, "No Shots")
                    continue

                for shot_code in sorted(shots_for_this_seq):
                    shot_content_widget = QtWidgets.QWidget()
                    self._setup_simple_scroll_content(shot_content_widget, [])
                    shots_in_seq_tab_widget.addTab(shot_content_widget, shot_code)
            
    def _create_main_tab_content_widget(self, tab_name):
        """
        Creates and returns the appropriate content widget for tabs added directly to `bottom_tab_widget`.
        This handles the nesting for Asset Types.
        """
        if tab_name in self.ASSET_TYPES:
            inner_tab_widget = QtWidgets.QTabWidget()
            
            for category_name in self.HAL_CATEGORY_TYPES:
                category_content_widget = QtWidgets.QWidget()
                self._setup_simple_scroll_content(category_content_widget, []) 
                inner_tab_widget.addTab(category_content_widget, category_name)
            
            return inner_tab_widget
            
        elif tab_name in self.SHOT_TYPES:
            shot_type_content_widget = QtWidgets.QWidget()
            self._setup_simple_scroll_content(shot_type_content_widget, []) 
            return shot_type_content_widget
        
        return QtWidgets.QWidget() 

    def _setup_simple_scroll_content(self, parent_widget, versions_data=None):
            """
            Sets up a basic scrollable area and populates it with thumbnail widgets.
            (Robust version that replaces the content widget to prevent UI glitches)
            """
            if versions_data is None:
                versions_data = []

            # --- START: New, Robust UI Clearing and Rebuilding ---

            # 1. Find and delete the old content widget if it exists.
            #    We assume the content is always the first (and only) widget in the parent's layout.
            if parent_widget.layout() and parent_widget.layout().count() > 0:
                old_widget = parent_widget.layout().itemAt(0).widget()
                if old_widget:
                    old_widget.deleteLater()

            # 2. Create a new, clean container widget for all our content.
            content_container = QtWidgets.QWidget()
            
            # 3. Create the layout for inside the new container.
            main_layout = QtWidgets.QVBoxLayout(content_container)
            main_layout.setContentsMargins(0, 0, 0, 0)
            main_layout.setSpacing(0)
            
            scroll = QtWidgets.QScrollArea()
            scroll.setWidgetResizable(True)
            scroll.setStyleSheet("QScrollArea { border: none; }") # Optional: for aesthetics

            container = QtWidgets.QWidget()
            content_layout = QtWidgets.QGridLayout(container)
            content_layout.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
            content_layout.setContentsMargins(10, 10, 10, 10)
            content_layout.setSpacing(10)
            
            container.setLayout(content_layout)
            scroll.setWidget(container)
            main_layout.addWidget(scroll)

            # 4. If the parent widget doesn't have a layout, create one.
            if not parent_widget.layout():
                parent_layout = QtWidgets.QVBoxLayout(parent_widget)
                parent_widget.setLayout(parent_layout)
            
            # 5. Add our new, fully-built content container to the parent.
            parent_widget.layout().addWidget(content_container)

            # --- END: New, Robust UI Clearing and Rebuilding ---


            # The logic for populating the grid layout remains the same as before.
            column_count = 5
            row, col = 0, 0
            if versions_data:
                for version in versions_data:
                    thumb_widget = self._create_thumbnail_widget(version)
                    content_layout.addWidget(thumb_widget, row, col)
                    col += 1
                    if col >= column_count:
                        col = 0
                        row += 1
                # Add spacers to keep items aligned to the top-left
                content_layout.addItem(QtWidgets.QSpacerItem(0, 0, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding), row + 1, 0, 1, column_count)
                content_layout.addItem(QtWidgets.QSpacerItem(0, 0, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum), 0, column_count, row + 2, 1)

            else:
                no_data_label = QtWidgets.QLabel("No items found for this category. Click 'Refresh' to load data.")
                no_data_label.setAlignment(QtCore.Qt.AlignCenter)
                content_layout.addWidget(no_data_label, 0, 0, 1, column_count, QtCore.Qt.AlignCenter)

    # <-- 新增：辅助方法，用于递归清理布局
    def _clear_layout(self, layout):
        if layout is not None:
            while layout.count():
                item = layout.takeAt(0)
                if item.widget() is not None:
                    item.widget().deleteLater()
                elif item.layout() is not None:
                    self._clear_layout(item.layout())
                    item.layout().deleteLater()

        
    def setup_options_panel(self, parent_widget): 
        """Setup content for the 'Options' widget (now a standalone panel)."""
        layout = QtWidgets.QVBoxLayout(parent_widget)
        
        title_label = QtWidgets.QLabel("Options")
        title_label.setAlignment(QtCore.Qt.AlignCenter)
        title_label.setStyleSheet("font-weight: bold; font-size: 14px; padding-bottom: 5px;")
        layout.addWidget(title_label)

        render_group = QtWidgets.QGroupBox("导入设置")
        render_layout = QtWidgets.QGridLayout()
        
        render_label = QtWidgets.QLabel("格式筛选:")
        self.render_combo = QtWidgets.QComboBox()
        # --- 修改这里：设置初始提示文本 ---
        self.render_combo.addItem("点击刷新加载格式...") 
        
        material_label = QtWidgets.QLabel("版本筛选:")
        self.material_combo = QtWidgets.QComboBox()
        
        render_layout.addWidget(render_label, 0, 0)
        render_layout.addWidget(self.render_combo, 0, 1)
        render_layout.addWidget(material_label, 1, 0)
        render_layout.addWidget(self.material_combo, 1, 1)
        render_group.setLayout(render_layout)
        
        layout.addWidget(render_group)
        layout.addStretch()


    def _analyze_shotgun_data_from_env(self):
        """
        Analyzes sequence and shot data from environment variables `SG_Find_Sequence` and `SG_Find_Shot`.
        Parses the data, groups shots by sequence, and returns sorted lists of sequences and shots.
        Returns:
            tuple: (sorted_sequence_codes, shots_codes_nested)
                   - sorted_sequence_codes (list): A list of sequence codes, sorted alphabetically.
                   - shots_codes_nested (list of lists): A list where each inner list contains
                                                         the sorted shot codes belonging to the
                                                         corresponding sequence in `sorted_sequence_codes`.
                                                         An empty list if a sequence has no shots.
        """
        sequences_str = os.environ.get("SG_Find_Sequence")
        shots_str = os.environ.get("SG_Find_Shot")

        if not sequences_str and not shots_str:
            print("Error: Environment variables SG_Find_Sequence and SG_Find_Shot are not set. Cannot perform analysis.")
            return [], []

        all_sequences = []
        all_shots = []

        if sequences_str:
            try:
                all_sequences = ast.literal_eval(sequences_str)
            except (ValueError, SyntaxError) as e:
                print(f"Error parsing SG_Find_Sequence: {e}")
                print(f"Partial content: {sequences_str[:200]}...")
                return [], []

        if shots_str:
            try:
                all_shots = ast.literal_eval(shots_str)
            except (ValueError, SyntaxError) as e:
                print(f"Error parsing SG_Find_Shot: {e}")
                print(f"Partial content: {shots_str[:200]}...")
                return [], []

        sequence_to_shots = {}

        # Initialize sequence_to_shots with all known sequences
        for seq_data in all_sequences:
            seq_code = seq_data.get('code')
            if seq_code:
                sequence_to_shots[seq_code] = []

        # Populate sequence_to_shots with shots
        for shot in all_shots:
            shot_code = shot.get('code')
            sequence_info = shot.get('sequence')
            seq_code_for_shot = None

            if sequence_info and sequence_info.get('code'):
                seq_code_for_shot = sequence_info['code']

            if shot_code:
                if seq_code_for_shot:
                    # If sequence is not yet in our map (e.g., from a shot, but not in SG_Find_Sequence explicitly)
                    if seq_code_for_shot not in sequence_to_shots:
                        sequence_to_shots[seq_code_for_shot] = []
                    sequence_to_shots[seq_code_for_shot].append(shot_code)
                else:
                    # Handle shots not assigned to any specific sequence
                    unassigned_key = "未分配序列"
                    if unassigned_key not in sequence_to_shots:
                        sequence_to_shots[unassigned_key] = []
                    sequence_to_shots[unassigned_key].append(shot_code)

        # Prepare return values: sorted sequences and corresponding sorted shots
        sorted_sequence_codes = sorted(sequence_to_shots.keys())
        shots_codes_nested = []

        for seq_code in sorted_sequence_codes:
            # Ensure shots within each sequence are also sorted
            shots_codes_nested.append(sorted(sequence_to_shots[seq_code]))

        return sorted_sequence_codes, shots_codes_nested
